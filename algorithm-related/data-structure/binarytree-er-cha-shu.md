# BinaryTree二叉树

二叉树是一个有根树，并且每个节点最多有2个子节点。非空的二叉树，若树叶总数为 n\_0，分支度为2的总数为 n\_2，则 n\_0 = n\_2 + 1。

## 1. 特殊类型

### 1.1 满二叉树

一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是\(2^k\) -1，则它就是满二叉树

### 1.2 完全二叉树

若设二叉树的深度为k，除第 k 层外，其它各层 \(1～k-1\) 的结点数都达到最大个数，第k 层所有的结点都**连续集中在最左边**，这就是完全二叉树。

完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。  


### 1.3 平衡二叉树

它或者是一颗空树，或它的左子树和右子树的深度之差\(平衡因子\)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。

### 1.4 二叉搜索树

二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

## 2. 遍历

### 2.1 深度优先遍历

前（先）序、中序、后序遍历

### 2.2 广度优先遍历

和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。

## 3. 相关例题

LeetCode 173, **Binary Search Tree Iterator**， **二叉搜索树迭代器** \[Medium\].

LeetCode 117,  **填充每个节点的下一个右侧节点指针 II** \[Medium\].

LeetCode 105, **从前序与中序遍历序列构造二叉树** \[Medium\].

LeetCode 106, **从中序与后序遍历序列构造二叉树** \[Medium\].

LeetCode 116, **填充每个节点的下一个右侧节点指针** \[Medium\].

LeetCode 103, **二叉树的锯齿形层次遍历** \[Medium\].

LeetCode 431, **将 N 叉树编码为二叉树** \[Hard\].

LeetCode 199, **二叉树的右视图** \[Medium\].

LeetCode 1373, **二叉搜索子树的最大键值和**   ****\[Medium\].

LeetCode 1372, **二叉树中的最长交错路径**   ****\[Medium\].

LeetCode 545, **二叉树的边界**   ****\[Medium\].

LeetCode 428, **序列化和反序列化 N 叉树**   ****\[Hard\].

LeetCode 545, **二叉树的边界**   ****\[Medium\].

LeetCode 1130, **叶值的最小代价生成树**    ****\[Medium\].

LeetCode 096, **不同的二叉搜索树**    ****\[Medium\].

LeetCode 543, **二叉树的直径**     ****\[Easy\].

LeetCode 208, **实现 Trie \(前缀树\)**    ****\[Medium\].

LeetCode 111, **二叉树的最小深度**     ****\[Easy\].

LeetCode 104, **二叉树的最大深度**     ****\[Easy\].

LeetCode 236, **二叉树的最近公共祖先**     ****\[Medium\].

LeetCode 235, **二叉搜索树的最近公共祖先**     ****\[Medium\].

LeetCode 102, **二叉树的层序遍历**     ****\[Medium\].

LeetCode 98, **验证二叉搜索树**     ****\[Medium\].



